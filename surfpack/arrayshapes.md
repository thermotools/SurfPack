All classes that implement new weighted densities that are used in the Helmholtz energy functional should, in addition to
`reduced_helmholtz_energy_density` also override the methods:

* `get_weights`
* `get_weighted_densities`

The method `get_weights` must return a list with shape `(nw, nc)`, where `nw` is the number of weighted densities used
by the model, and `nc` is the number of components in a mixture. The elements in the list can be either `float`s (bulk)
or `Analytical`s (not bulk). 
(Note: This means that we can probably generalise the method `get_weighted_densities` at the `Functional` level). 

The method `get_weighted_densities` should return a list with shape `(nw,)` i.e. a 1d list, with each element being
the weighted density computed from the corresponding list of weights in the 2d list returned by `get_weights`. 

We express a general weighted density as

$$
n_{\alpha} = \sum_i w_i^{(\alpha)} * \rho_i,
$$
thus, if the matrix $W$ is returned by `get_weights`, and $\rho$ is the vector of density profiles, the method `get_weighted_densities`
simply returns the vector.
$$
n = W * \rho.
$$
Note that the matrix W is in general quite sparse, because a lot of weighted densities (basically everything except FMT)
are computed from a single components' density profile (i.e. the diagonal element of W).

so `weighted_densities[i]` is generated by summing over the weights in `weights[i]`, where `weights` is the 2d array
returned by `get_weights`.

Furthermore, the method `helmholtz_energy_density`, when called with `dphidn=True`, should return `dphidn` as a list
with shape `(nw,)`, with each element being the derivative of the helmholtz energy density wrt. the corresponding
weighted density.

When a weighted density only uses one (or generally: not all) component densities, the weights are just set to `0`. 
So for the dispersion weighted densities in a two-component mixture

$$
n_1^{(disp)} = w_1^{(disp)} * \rho_1, n_2^{(disp)} = w_2^{(disp)} * \rho_2
$$

what we do is rewrite this as

$$
n_{disp, 1} = w_1^{(disp, 1)} * \rho_1 + w_2^{(disp, 1)} \rho_2
n_{disp, 2} = w_1^{(disp, 2)} * \rho_1 + w_2^{(disp, 2)} \rho_2
$$

and set $w_2^{(disp, 1)} = w_1^{(disp, 2)} = 0$. The reason for doing this is being able to generalise the correlation
functions as

$$
c_i = - \sum_{\alpha} w_i^{(\alpha)} * \partial \phi / \partial n_{\alpha}.
$$

as well as more easily generalising other iterations over weights and components. 

To summarise: